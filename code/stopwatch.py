# ========================================
# СЕКУНДОМЕР НА LVGL ДЛЯ МИКРОКОНТРОЛЛЕРА
# ========================================
# Этот код создаёт графический интерфейс секундомера
# с кнопкой запуска/остановки и отображением времени ЧЧ:ММ:СС

import lvgl as lv          # Графическая библиотека LVGL для создания интерфейсов
import lvgl_helper as lv_h  # Вспомогательные функции для работы с дисплеем
import lcd                 # Драйвер ЖК-дисплея
import touchscreen as ts   # Драйвер сенсорного экрана
import time                # Работа со временем и задержками

# ------------------------------
# 1. ИНИЦИАЛИЗАЦИЯ АППАРАТНЫХ КОМПОНЕНТОВ
# ------------------------------
# Включаем дисплей и сенсорный экран
lcd.init()
ts.init()
# Инициализируем графическую библиотеку LVGL
lv.init()

# ------------------------------
# 2. НАСТРОЙКА БУФЕРА ОТОБРАЖЕНИЯ
# ------------------------------
# Буфер используется для временного хранения изображения перед выводом на экран
disp_buf = lv.disp_buf_t()                     # Создаём объект буфера
buf = bytearray(320 * 10)                      # Выделяем память: 320 пикселей × 10 строк
# Инициализируем буфер: передаём память, второй буфер (None = не используется),
# и количество пикселей, обрабатываемых за раз
lv.disp_buf_init(disp_buf, buf, None, len(buf) // 4)

# ------------------------------
# 3. НАСТРОЙКА ДИСПЛЕЯ В LVGL
# ------------------------------
disp_drv = lv.disp_drv_t()                     # Создаём драйвер дисплея
lv.disp_drv_init(disp_drv)                     # Инициализируем его
disp_drv.buffer = disp_buf                     # Привязываем буфер к драйверу
disp_drv.flush_cb = lv_h.flush                 # Функция вывода изображения на экран
disp_drv.hor_res = 320                         # Горизонтальное разрешение (ширина)
disp_drv.ver_res = 240                         # Вертикальное разрешение (высота)
lv.disp_drv_register(disp_drv)                 # Регистрируем драйвер в системе

# ------------------------------
# 4. НАСТРОЙКА СЕНСОРНОГО ЭКРАНА
# ------------------------------
indev_drv = lv.indev_drv_t()                   # Создаём драйвер ввода
lv.indev_drv_init(indev_drv)                   # Инициализируем его
indev_drv.type = lv.INDEV_TYPE.POINTER         # Тип устройства: указатель (палец/стилус)
indev_drv.read_cb = lv_h.read                  # Функция чтения координат касания
lv.indev_drv_register(indev_drv)               # Регистрируем драйвер ввода

# Получаем активный экран для размещения элементов интерфейса
scr = lv.scr_act()

# ------------------------------
# 5. ПЕРЕМЕННЫЕ СЕКУНДОМЕРА
# ------------------------------
hours = 0      # Счётчик часов
minutes = 0    # Счётчик минут
seconds = 0    # Счётчик секунд
running = False  # Флаг состояния: идёт отсчёт или остановлен

# ------------------------------
# 6. СОЗДАНИЕ ЭЛЕМЕНТОВ ИНТЕРФЕЙСА
# ------------------------------
# Метка для отображения времени
time_label = lv.label(scr)                     # Создаём текстовую метку на экране
time_label.set_text("00:00:00")                # Устанавливаем начальный текст

# Центрируем метку по горизонтали в верхней части экрана
# (с отступом 40 пикселей сверху)
try:
    time_label.align(None, lv.ALIGN.IN_TOP_MID, 0, 40)
except:
    # Совместимость с разными версиями LVGL: если метод не поддерживается,
    # элемент останется в левом верхнем углу (умолчание)
    pass

# Функция обновления текста времени в формате ЧЧ:ММ:СС
def set_time_text():
    # {:02d} — форматирование: число с ведущим нулём (например, 5 → "05")
    time_label.set_text("{:02d}:{:02d}:{:02d}".format(hours, minutes, seconds))

# ------------------------------
# 7. КНОПКА ЗАПУСК/СТОП
# ------------------------------
# Обработчик событий кнопки
def btn_event_handler(obj, event):
    global running  # Используем глобальную переменную состояния
    if event == lv.EVENT.CLICKED:  # Если произошло нажатие
        running = not running      # Переключаем состояние (пуск ↔ стоп)
        if running:
            btn_label.set_text("STOP")   # Меняем надпись на "STOP"
        else:
            btn_label.set_text("START")  # Меняем надпись на "START"

# Создаём кнопку
btn = lv.btn(scr)                      # Кнопка на основном экране
btn.set_size(120, 60)                  # Размер кнопки: ширина 120px, высота 60px

# Позиционируем кнопку по центру в нижней части экрана
# (с отступом 30 пикселей снизу)
try:
    btn.align(None, lv.ALIGN.IN_BOTTOM_MID, 0, -30)
except:
    pass

# Назначаем обработчик событий кнопке
btn.set_event_cb(btn_event_handler)

# Создаём текстовую метку ВНУТРИ кнопки
btn_label = lv.label(btn)              # Метка является дочерним элементом кнопки
btn_label.set_text("START")            # Начальная надпись
btn_label.align(None, lv.ALIGN.CENTER, 0, 0)  # Центрируем текст в кнопке

# ------------------------------
# 8. ГЛАВНЫЙ ЦИКЛ ПРОГРАММЫ
# ------------------------------
# Инициализируем таймеры для синхронизации
lv_tick_ms = time.ticks_ms()   # Для обновления графики LVGL
sw_tick_ms = time.ticks_ms()   # Для отсчёта секунд в секундомере

while True:
    # --- Обновление графического интерфейса (каждые 5 мс) ---
    if time.ticks_ms() - lv_tick_ms > 5:
        lv_tick_ms = time.ticks_ms()
        lv.task_handler()   # Выполняем внутренние задачи LVGL (анимации, события)
        lv.tick_inc(5)      # Сообщаем LVGL, что прошло 5 мс

    # --- Логика секундомера (каждую секунду) ---
    if running and (time.ticks_ms() - sw_tick_ms >= 1000):
        sw_tick_ms = time.ticks_ms()  # Сбрасываем таймер секундомера

        # Увеличиваем счётчик секунд
        seconds += 1
        
        # Автоматический перенос при достижении пределов:
        if seconds >= 60:
            seconds = 0
            minutes += 1
        if minutes >= 60:
            minutes = 0
            hours += 1
        if hours >= 24:
            hours = 0  # Сброс после 24 часов (можно изменить по желанию)
        
        # Обновляем отображение времени на экране
        set_time_text()
    
    # Короткая пауза для снижения нагрузки на процессор
    time.sleep_ms(1)